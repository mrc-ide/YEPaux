# Functions relating to processing of Markov Chain Monte Carlo output data
#-------------------------------------------------------------------------------
#' @title get_mcmc_params
#'
#' @description Identify columns in MCMC output data containing fitted parameter values and get parameter names
#'
#' @details This function takes in a dataset output by mcmc() and extracts the names of the fitted parameters as a
#'   vector
#'
#' @param chain Data frame containing MCMC output
#' '
#' @export
#'
get_mcmc_params <- function(chain=list()){

  assert_that(is.data.frame(chain))
  column_names=colnames(chain)
  assert_that("posterior_current" %in% column_names)
  assert_that("flag_accept" %in% column_names)

  if("posterior_prop" %in% column_names){n_start=3} else {n_start=2}
  n_end=match("flag_accept", column_names)-1
  columns=c(n_start:n_end)
  param_names=column_names[columns]

  return(param_names)
}
#-------------------------------------------------------------------------------
#' @title get_mcmc_data
#'
#' @description Read MCMC results from CSV files in folder; plot likelihood graph and/or output data set
#'
#' @details This function is intended to read the output of the mcmc() function saved as CSV files over the course of
#' a run. It reads all CSV files in specified folder (ignoring subfolders) in alphabetical order and combines them
#' into a single data frame. It  outputs the data frame and optionally plots the posterior likelihood on a graph.
#'
#' @param input_folder Folder containing CSV files output by mcmc()
#' @param plot_graph TRUE/FALSE flag indicating whether to plot graph of likelihood values
#' '
#' @export
#'
get_mcmc_data <- function(input_folder="", plot_graph=TRUE){

  assert_that(file.exists(input_folder), msg="Valid input folder must be specified")

  file_list=list.files(path=input_folder, pattern="*.csv")
  input_frame=data.frame()
  for(i in 1:length(file_list)){
    data=read.csv(paste(input_folder, file_list[i], sep="/"), header=TRUE)
    if(i==1){
      param_names=get_mcmc_params(data)
      columns=colnames(data) %in% c("posterior_current", param_names)
    }
    input_frame<-rbind(input_frame, data[, columns])
  }

  if(plot_graph==TRUE){
    matplot(x=c(1:nrow(input_frame)), y=input_frame$posterior_current, type="l", xlab="Iteration", ylab="LogLikelihood")}

  return(input_frame)
}
#-------------------------------------------------------------------------------
#' @title truncate_mcmc_data
#'
#' @description Take MCMC results generated by get_mcmc_data and extract selected lines; optionally plot likelihood
#' graph and/or output data set
#'
#' @details This function takes in a data frame output by the get_mcmc_data() function and outputs a data frame
#' consisting only of the selected lines; it can be used to cut off all pre-burnin points in the Markov chain and/or
#' to obtain a selection of points along part of the chain. A graph of the posterior likelihood values in the
#' truncated data frame can optionally be plotted.
#'
#' @param input_frame Data frame of MCMC output data produced by get_mcmc_data(), truncate_mcmc_data() and/or
#'   combine_multichain()
#' @param rows Vector of line numbers to extract from input_frame
#' @param plot_graph TRUE/FALSE flag indicating whether to plot results graph
#' '
#' @export
#'
truncate_mcmc_data <- function(input_frame=list(), rows=c(1), plot_graph=TRUE){
  assert_that(is.data.frame(input_frame))
  assert_that("posterior_current" %in% colnames(input_frame))
  assert_that(is.integer(rows))
  assert_that(is.logical(plot_graph))

  line_list=c(1:nrow(input_frame))
  input_frame <- cbind(input_frame, line_list)
  input_frame_truncated=input_frame[rows, ]

  if(plot_graph==TRUE){matplot(x=rows, y=input_frame_truncated$posterior_current,
                               type="l", xlab="Iteration", ylab="LogLikelihood")}

  return(input_frame_truncated)
}
#-------------------------------------------------------------------------------
# TODO - Update for mixed constant/variable environmental covariates
# TODO - Get rid of different modes, assume type="FOI+R0 enviro"
#' @title get_mcmc_FOI_R0_data
#'
#' @description Extract spillover force of infection (FOI) and reproduction number (R0) values from MCMC output data
#'
#' @details This function takes in a data frame produced by functions get_mcmc_data(), truncate_mcmc_data() and/or
#' combine_multichain() and calculates spillover force of infection (FOI) and reproduction number (R0) values for
#' each row in the frame (representing points on the chain) based on the type of fit carried out.
#'
#' TBA
#'
#' @param input_frame Data frame of MCMC output data produced by get_mcmc_data(), truncate_mcmc_data() and/or
#'   combine_multichain() OR data frame containing parameter values as columns with parameter names as column headings
#' @param enviro_data_const TBA
#' @param enviro_data_var TBA
#' '
#' @export
#'
get_mcmc_FOI_R0_data <- function(input_frame=list(), enviro_data_const=list(), enviro_data_var=NULL){
  assert_that(is.data.frame(input_frame))
  assert_that(is.data.frame(enviro_data_const))

  if("flag_accept" %in% colnames(input_frame)){
    param_names=get_mcmc_params(input_frame)
  } else {
    param_names=colnames(input_frame)
  }
  param_names=param_names[param_names != "posterior_current"]
  columns=which(colnames(input_frame) %in% param_names)

  regions=enviro_data_const$region
  n_regions=length(regions)
  n_lines=nrow(input_frame)

  #TODO - Add assert_that functions

  if(is.null(enviro_data_var)){
    n_env_vars=ncol(enviro_data_const)-1
    covar_names=colnames(enviro_data_const)[1+c(1:n_env_vars)]

    assert_that(all(param_names[c(1:n_env_vars)]==paste("FOI_", covar_names, sep="")),
                msg="Environmental covariates in environmental data and input frame must match")
    assert_that(all(param_names[n_env_vars+c(1:n_env_vars)]==paste("R0_", covar_names, sep="")),
                msg="Environmental covariates in environmental data and input frame must match")
    columns_FOI=which(substr(colnames(input_frame),1,3)=="FOI")
    columns_R0=which(substr(colnames(input_frame),1,2)=="R0")

    blank=rep(NA, n_regions*n_lines)
    output_frame=data.frame(n_region=as.factor(rep(c(1:n_regions), n_lines)),
                            region=rep(regions, n_lines), FOI=blank, R0=blank)

    output_frame$FOI=as.vector(as.matrix(enviro_data_const[,1+c(1:n_env_vars)]) %*% t(as.matrix(input_frame[,columns_FOI])))
    output_frame$R0=as.vector(as.matrix(enviro_data_const[,1+c(1:n_env_vars)]) %*% t(as.matrix(input_frame[,columns_R0])))

    if("m_FOI_Brazil" %in% colnames(input_frame)){
      for(i in 1:n_regions){
        if(substr(regions[i], 1, 3)=="BRA"){
          lines=i+(n_regions*c(0:(n_lines-1)))
          output_frame$FOI[lines]=output_frame$FOI[lines]*input_frame$m_FOI_Brazil
        }
      }
    }
    output_frame$FOI[output_frame$FOI<0.0]=0.0
    output_frame$R0[output_frame$R0<0.0]=0.0

  }else{ #TODO - Finish coding output generation for variable input
    # #TODO - Add assert_that
    # const_covars = colnames(enviro_data_const)[c(2:ncol(enviro_data_const))]
    # var_covars = enviro_data_var$env_vars
    # covar_names = c(const_covars,var_covars)
    # n_env_vars = length(covar_names)
    # i_FOI_const = c(1:n_env_vars)[covar_names %in% const_covars]
    # i_FOI_var = c(1:n_env_vars)[covar_names %in% var_covars]
    # i_R0_const = i_FOI_const + n_env_vars
    # i_R0_var = i_FOI_var + n_env_vars
    #
    # #TODO - Create output structure
    #
    # #TODO - Edit to calculate in fewer steps for greater speed?
    # for(line in 1:n_lines){
    #   output_frame$FOI[]=epi_param_calc(coeffs_const = input_frame[,i_FOI_const],coeffs_var = input_frame[line,i_FOI_var],
    #                                          enviro_data_const, enviro_data_var)
    #   output_frame$R0[]=epi_param_calc(coeffs_const = input_frame[,i_R0_const],coeffs_var = input_frame[line,i_R0_var],
    #                                         enviro_data_const, enviro_data_var)
    # }
  }

  #TODO - Put region names in?

  return(output_frame)
}
#-------------------------------------------------------------------------------
#' @title get_mcmc_enviro_coeff_data
#'
#' @description Extract values of environmental coefficients from MCMC output data
#'
#' @details This function takes in a data frame produced by functions get_mcmc_data() and/or truncate_mcmc_data() and
#' calculates values of the coefficients of environmental covariates for each row in the frame
#' (representing points on the chain) based on the type of fit carried out.
#'
#' @param input_frame Data frame of MCMC output data produced by get_mcmc_data(), truncate_mcmc_data() and/or
#'   combine_multichain() OR data frame containing parameter values as columns with parameter names as column headings
#' @param type Type of parameter set (FOI and/or R0 coefficients associated with environmental
#'   covariates); choose from "FOI enviro", "FOI+R0 enviro"
#' '
#' @export
#'
get_mcmc_enviro_coeff_data <- function(input_frame=list(), type="FOI+R0 enviro"){
  assert_that(is.data.frame((input_frame)))
  assert_that(type %in% c("FOI enviro", "FOI+R0 enviro"))

  if("flag_accept" %in% colnames(input_frame)){param_names=get_mcmc_params(input_frame)} else {
    param_names=colnames(input_frame)}
  param_names=param_names[param_names != "posterior_current"]
  columns=which(colnames(input_frame) %in% param_names)

  columns_FOI_coeffs=which(substr(colnames(input_frame), 1, 3)=="FOI")
  n_env_vars=length(columns_FOI_coeffs)
  env_vars=substr(param_names[c(1:n_env_vars)], 5, 1000)

  n_lines=nrow(input_frame)
  blank=rep(NA, n_env_vars*n_lines)
  output_frame=data.frame(n_env_var=as.factor(rep(c(1:n_env_vars), n_lines)), env_var=blank, FOI_coeffs=blank)
  output_frame$env_var=env_vars[output_frame$n_env_var]
  if(type=="FOI+R0 enviro"){
    R0_coeffs=blank
    output_frame=cbind(output_frame, R0_coeffs)}

  columns1=columns[c(1:n_env_vars)]
  output_frame$FOI_coeffs=as.vector(t(input_frame[, columns1]))
  if(type=="FOI+R0 enviro"){
    columns2=columns[c(1:n_env_vars)]+n_env_vars
    output_frame$R0_coeffs=as.vector(t(input_frame[, columns2]))
  }

  return(output_frame)
}
